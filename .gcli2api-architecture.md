# gcli2api 项目架构速览（面向有基础的 CS 学生）

本说明专门写给「有一定基础、但不习惯小脚本/玩具项目风格」的你：把这个项目当成一个迷你「多后端、统一网关、集中凭证管理的代理服务」，而不是零散脚本集合。

核心关键词：
- 统一入口（HTTP 网关）
- 统一凭证与状态管理
- 可插拔存储后端（文件 / Redis / Postgres / MongoDB）
- 对上游大模型 API 做路由、配额与降级控制

---

## 1. 整体角色和数据流

从外到内可以分 4 层来看：

1. 客户端层（调用方）
   - 调用方式：
     - OpenAI 格式调用
     - Gemini / Google 风格调用
   - 他们只看到一个统一服务：本项目暴露的 HTTP API。

2. 网关 / 路由层
   - 入口脚本：
     - [`web.py`](web.py:1)
     - [`multi_user_auth_web.py`](multi_user_auth_web.py:1)
   - 主要职责：
     - 启动 FastAPI / Web 服务器
     - 加载路由定义（见 [`src.web_routes`](src/web_routes.py:1)）
     - 对请求做基础校验（密码、路径、参数）
     - 把逻辑交给后端路由器：
       - [`src.openai_router`](src/openai_router.py:1)
       - [`src.gemini_router`](src/gemini_router.py:1)

3. 业务逻辑层（这一层是项目精华）
   - 核心组件：
     - 凭证管理：
       - [`src.credential_manager`](src/credential_manager.py:1)
     - 授权与用户信息：
       - [`src.auth`](src/auth.py:1)
       - [`src.google_oauth_api`](src/google_oauth_api.py:1)
     - 调用路由与封装：
       - [`src.openai_router`](src/openai_router.py:1)
       - [`src.gemini_router`](src/gemini_router.py:1)
       - [`src.google_chat_api`](src/google_chat_api.py:1)（与 Google 相关）
     - 状态与使用统计：
       - [`src.usage_stats`](src/usage_stats.py:1)
       - [`src.state_manager`](src/state_manager.py:1)（历史遗留/兼容）
       - [`src.task_manager`](src/task_manager.py:1)（统一后台任务）
     - 工具与适配：
       - [`src.anti_truncation`](src/anti_truncation.py:1)
       - [`src.utils`](src/utils.py:1)
       - [`src.format_detector`](src/format_detector.py:1)
   - 你可以把这一层理解成：
     - 做「配额控制、凭证轮换、错误自动屏蔽」的服务网关核心逻辑。
     - 把上游复杂/不稳定的 API 包一层「稳定接口」。

4. 存储与基础设施层（State / Config / 多后端）
   - 统一存储适配器：
     - [`src.storage_adapter`](src/storage_adapter.py:1)
       - 决定实际使用哪种后端：Redis > Postgres > MongoDB > 本地文件。
       - 对上暴露统一接口：
         - store/get/list/delete_credential()
         - update/get_all_credential_states()
         - update/get_all_usage_stats()
         - set/get_config()
   - 各具体实现：
     - 本地文件：
       - [`src.storage.file_storage_manager`](src/storage/file_storage_manager.py:1)
       - 使用 `creds.toml` + `config.toml`，结构「扁平化」。
     - Redis：
       - [`src.storage.redis_manager`](src/storage/redis_manager.py:1)
       - 使用 Redis Hash 存所有凭证记录，同样是「扁平化状态」。
     - Postgres：
       - [`src.storage.postgres_manager`](src/storage/postgres_manager.py:1)
     - MongoDB：
       - [`src.storage.mongodb_manager`](src/storage/mongodb_manager.py:1)
   - 配置读取：
     - [`config.py`](config.py:1)
       - 优先级：环境变量 > 存储配置 > 默认值
       - 管理：
         - 服务端口、密码
         - 模型列表与特性
         - 自动封禁、429 重试策略等

---

## 2. CredentialManager：真正的「大脑」

[`src.credential_manager`](src/credential_manager.py:1) 是整个项目的核心。

可以把它当成一个「多凭证调度器 + 状态机」：

- 初始化时：
  - 通过 [`get_storage_adapter`](src/storage_adapter.py:344) 选择后端（文件/Redis/...）。
  - 扫描所有可用凭证文件名。
  - 启动后台任务（轮询、恢复）。

- 核心职责：
  1. 选择可用凭证：
     - 自动跳过：
       - 被禁用的 (`disabled = True`)
       - 被标记为限流的 (`is_rate_limited = True`)
     - 支持轮换（按调用次数 rotation）。
  2. 维护 24 小时滚动窗口：
     - 每个凭证维护：
       - `first_use_timestamp`
       - `next_reset_timestamp`
       - （再叠加调用统计由 usage_stats / 上层逻辑管理）
     - 第一次使用时启动 24h 窗口。
     - 到期后自动重置窗口。
  3. 429 / 异常处理集成：
     - 上层如果收到 429：
       - 调用 `mark_rate_limited(credential, True)`：
         - 写入 `is_rate_limited = True`
         - 如无窗口信息，则从当前时间开始补一个 24h 窗口
         - 强制轮换到下一个凭证
     - 后台任务定期扫描：
       - 到 `next_reset_timestamp` 自动解封，并重进可用池。
  4. 状态一致性：
     - 所有状态最终都落在统一存储（Redis / 文件 / 等）。
     - 多进程 / 多实例可通过共享存储看到一致状态（前提是你在真实分布式部署时正确配置存储后端）。

这部分可以从「服务编排」的角度来理解，而不是「写 JSON 的脚本」：
- 它抽象了「凭证是有生命周期、有状态的实体」，并通过存储后端保持持久化。

---

## 3. 存储后端一致性设计（避免“小项目乱写状态”的坑）

项目一开始是文件驱动的，后来引入 Redis / DB，为了避免「每个地方都各写一套状态结构」的灾难，引入了：

- [`StorageAdapter`](src/storage_adapter.py:87)
  - 核心是用统一接口屏蔽后端差异。
- 本地文件版 [`FileStorageManager`](src/storage/file_storage_manager.py:60)
  - 使用 TOML + 统一字段模板 `_DEFAULT_STATE_TEMPLATE`。
- Redis 版 [`RedisManager`](src/storage/redis_manager.py:71)
  -（近期修正）对齐为：
    - 同样使用扁平字段（含 `is_rate_limited`, `first_use_timestamp`, `next_reset_timestamp`）。
    - 统一通过缓存管理器读写 Hash。
- 上层的 [`CredentialManager`](src/credential_manager.py:17)
  - 只认「统一字段」，不感知存储细节。

对你来说，重点是意识到：
- 这是一个「有明确边界的存储抽象层 + 业务逻辑层」结构；
- 而不是东一块西一块状态文件的脚本堆。

---

## 4. 路由器与上游 API：把「玩具调用」变成「网关模式」

两个主要路由器：

- [`src.openai_router`](src/openai_router.py:1)
- [`src.gemini_router`](src/gemini_router.py:1)

它们做的事情共通：

1. 接受来自客户端的 HTTP 请求（多为 OpenAI 风格或定制格式）。
2. 做必要的参数翻译与包装。
3. 向上游（Google / Gemini / 其他）发起请求；
   - 通常通过内部封装模块（如 [`src.google_chat_api`](src/google_chat_api.py:1) 等）。
4. 调用前：
   - 向 `CredentialManager` 请求一个当前可用凭证。
5. 调用后：
   - 根据响应结果更新使用统计 / 状态：
     - 成功：更新 `last_success`，调用计数等。
     - 429：标记 `is_rate_limited`，触发轮换。
     - 特定错误码：根据配置自动禁用 / 拉黑。

你可以把它当成一个：

-「在 API Provider 之前，再加一层“平台侧网关”」：
- 做统一签名、统一鉴权、统一重试 / 冷却策略；
- 暴露给终端用户看起来是一个稳定的「OpenAI 风格」接口。

---

## 5. 前端控制面板：不是玩具 UI，而是 Ops 界面

文件在：

- [`front/control_panel.html`](front/control_panel.html:1)
- [`front/control_panel_mobile.html`](front/control_panel_mobile.html:1)
- [`front/multi_user_auth_web.html`](front/multi_user_auth_web.html:1)

用途：

- 管理和观察：
  - 当前凭证列表
  - 每个凭证的启用状态 / 是否限流
  - 24 小时窗口的起始时间 / 下次重置时间
  - 剩余时间倒计时
- 这些数据来自后端：
  - `CredentialManager` + `StorageAdapter` 提供统一状态视图。

从工程视角看，它是：

-「面向运维 / 管理员的简单控制台」，
- 而不是单纯演示页面。

---

## 6. 如何用「正规项目视角」理解这个仓库

如果你不想把它当「魔改脚本」，可以这样 mentally map：

- `web.py` / `multi_user_auth_web.py`
  - ≈ 网关服务的启动入口（类似 `main.go` / `cmd/server/main.py`）。
- `src/credential_manager.py`
  - ≈ 一个有状态的「Credential Service」。
- `src/storage_adapter.py` + `src/storage/*`
  - ≈「Repository / DAO 层 + 多实现」。
- `src/openai_router.py` / `src/gemini_router.py`
  - ≈「Controller + Upstream Client 封装」。
- `front/` 下的 HTML
  - ≈ 简化版「运维面板前端」。

整体模式接近：

- Clean Architecture / Hexagonal 的简化实现：
  - 外层是 HTTP 接口；
  - 中间是业务服务（凭证与配额）；
  - 底层是可替换的数据存储适配器。

---

## 7. 你真正需要记住的几个点

如果你之后要改这个项目或加功能，只需要牢牢记住：

1. 不要直接碰具体存储，实现一律走 [`StorageAdapter`](src/storage_adapter.py:87)。
2. 所有与「这个 key 能不能用」相关的逻辑，都应该集中在 [`CredentialManager`](src/credential_manager.py:17)。
3. 任何限流、封禁、重试策略，都尽量通过：
   - 标记状态（`is_rate_limited`, `disabled`, `error_codes` 等）
   - 交给后台任务和统一调度，而不是在各处写 if/else。
4. 把这个项目当成「生产网关的简化版」，而不是「跑 Demo 的脚本集合」。

这样，你会发现这个仓库其实比第一眼看上去要「正规」得多，只是历史演进导致文件有点散，但整体架构思想是清晰的。